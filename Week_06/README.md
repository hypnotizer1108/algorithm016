## 动态规划

一般来说动态规划的问题是要求一个最优解（或者最大最小值），正是因为存在最优子结构，所以在中间过程中不需要把所有的状态都保存下来，只需要存最优的状态，在此基础上还需要证明当每一步都存着一个最优的值，最后就能推导出一个全局的最优值。由此可以看出，动态规划的问题需要引入缓存（状态存储数组）并且在每一步都把次优的状态淘汰掉，只保留在这一步中最优的状态，最终推导出全局的最优解。

### 关键点 ###

1. 动态规划和递归或分治没有根本上的区别（关键看有无最优子结构）
2. 共性：找到重复子问题
3. 差异性：最优子结构，中间可以淘汰次优解

### 解题技巧 ###

先从base case出发求解，然后由base case进一步求出与之相关的下一个问题的解，在重复求解简单问题的过程中推导出递推公式，或者说dp方程。

**DP的题目求解时通常可以采用一种自底向上的方式来求解，原因在于最底层的解是已知的。**

以爬楼梯为例，求第1000阶的爬法，分析时不难推出f(1000) = f(999) + f(998)，但是实际上f(999)和f(998)是未知的，还需要计算下一层f(997)、f(996)...这其实是自顶向下的思路。
换一种思路，由于最底层的f(1)和f(2)的结果是已知的，且我们知道f(n) = f(n-2) + f(n-1)，由f(1)和f(2)求得f(3)，再求得f(4)，f(5)...最终得到f(1000)，这其实就是一种自底向上的解决思路。

```java
public class Solution {
    public int climbStairs(int n) {
    	if (n < 3) return n;
		int first = 1, second = 2;
		// 自底向上的求解
		for (int i = 3; i <= n; i++) {
			int total = first + second;
			first = second;
			second = total;
		}
		return second;
	}
}
```

**DP问题需要记录状态。最容易想到的办法是根据题目的数据选择用一维数组、二维数组等来记录下所有状态，这样做没有问题，但是在完成最基础的DP的前提下，可以考虑是否必须记录下所有状态？能否进一步优化空间？**

比如爬楼梯问题，可以用一个长度为n的数组来记录下所有状态，空间复杂度为O(n)。但是，不难发现dp[i]实际上只与dp[i-1]和dp[i-2]有关，不需要记录所有状态，只需要两个变量分别记录dp[i-1]和dp[i-2]的值即可，将空间复杂度优化到O(1)。

又比如[最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)，不难想到另开一个二维数组来记录状态，空间复杂度为O(m*n)。但是既然状态表也是m*n的，和grid一致，且这个问题中每个元素只计算一次，已经计算出的结果后续不会修改，那么可以直接在原grid上进行修改，无需另开dp数组



[最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence)问题中，解题的关键是将问题转换为用二维数组来记录两个字符串的LCS。
